pragma zkay ^0.2.0;

/*
 * Call vote(1) to vote for Yes, vote(-1) to vote for No.
 * Every eligible address can only vote once. Votes can only be cast before the result is announced.
 * What someone voted for is secret; but whether someone has voted is not.
 * As long as not all 3 vote counters are corrupt, what each person voted for remains secret.
 * If all 3 vote counters are corrupt, they can conspire to recover what each voter voted for.
 */
contract Referendum {

	final address counter1;
	final address counter2;
	final address counter3;
	mapping(address!x => uint32@x<+>) votes;
	mapping(address => bool) hasVoted;

	uint resultsAnnounced;
	mapping(address => uint32) results;
	uint32 combinedResult;

	constructor(address c1, address c2, address c3) public {
		counter1 = c1;
		counter2 = c2;
		counter3 = c3;
	}

	function vote(uint32@me my_vote, uint32@me rand1, uint32@me rand2, uint32@me rand3) public {
		require(!hasVoted[me]);
		require(resultsAnnounced == 0);
		require(reveal(my_vote == -1 || my_vote == 1, all));    // TODO: fix to work with unsigned votes

		votes[counter1] += reveal(my_vote + rand1 - rand2, counter1);
		votes[counter2] += reveal(my_vote + rand2 - rand3, counter2);
		votes[counter3] += reveal(my_vote + rand3 - rand1, counter3);
		hasVoted[me] = true;
	}

	function countVotes() public {
		// require(deadlineHasPassed);
		require(me == counter1 || me == counter2 || me == counter3);
		results[me] = reveal(votes[me], all);
		resultsAnnounced++;
	}

	function getResult() public returns (uint32) {
		require(resultsAnnounced == 3);
		combinedResult = (results[counter1] + results[counter2] + results[counter3]) / 3;
		return combinedResult;
	}
}
